<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///create server data structures
var get_port = get_integer("Port for server",2727);
global.max_server_players  = get_integer("Max players",32);
server = network_create_server(network_socket_tcp,get_port,global.max_server_players);

if server &gt;= 0 {
    with obj_mainmenu instance_destroy();

    //sockets point to playerlist entries.  list_sockets[| socket] = actual player number!!!
    list_sockets = ds_list_create();
    
    //playerlist, stores a references to the ds_maps the players control!
    list_player = ds_list_create();
    
    //entities! stores ds_maps of entities
    list_entities = ds_list_create();
    
    //make a test entity
    var new_entity = scr_entity_template_library(obj_puppet_cup,2016,2016,0,0,0,false,-1);
    scr_server_entity_add(new_entity); //add to main list
    
    //make a test entity
    var new_entity = scr_entity_template_library(obj_puppet_cup,2016,2048,0,0,0,false,-1);
    scr_server_entity_add(new_entity); //add to main list
    
    //make a test entity
    var new_entity = scr_entity_template_library(obj_puppet_cup,2016,2080,0,0,0,false,-1);
    scr_server_entity_add(new_entity); //add to main list
    
    //make a test entity
    var new_entity = scr_entity_template_library(obj_puppet_borb,2080,2048,0,0,0,false,-1);
    scr_server_entity_add(new_entity); //add to main list
    
    //make a test entity
    var new_entity = scr_entity_template_library(obj_puppet_toolbox,2080,2108,0,0,0,false,-1);
    scr_server_entity_add(new_entity); //add to main list
}
else
{
    show_message_async("Server failed to start!");
}

//map limits!
map_boundingx = 4096;
map_boundingy = 4096;

//entity update timer
player_update_timer = 2;
alarm[0] = player_update_timer;
entity_batch_counter = 0; //keeps track of the entity loader position
entity_batch_size = 10; //each time the clock counts down it updates this many entities from the list. stopping big entity cycles from clogging the server
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///send entity updates!
if entity_batch_counter &gt;= ds_list_size(list_entities) entity_batch_counter = 0;

var start_count = entity_batch_counter;

for (; entity_batch_counter&lt;start_count+entity_batch_size; entity_batch_counter += 1) {
    if entity_batch_counter &lt; ds_list_size(list_entities) {
        if is_undefined(list_entities[| entity_batch_counter]) == false and ds_exists(list_entities[| entity_batch_counter],ds_type_map) {
            scr_server_entity_massupdate(entity_batch_counter);
        }
    }
    else
    {
        //end loop EARLY!
        entity_batch_counter = 0;
        break;
    }
}


//reset sync timer
alarm[0] = player_update_timer;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///connection handling
if async_load[? "type"] == network_type_connect {
    var connection_id = async_load[? "socket"];

    //for now no logins, just trigger to the client that they logged in!
    scr_cpacket_requestseen(connection_id);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Data handling

//THESE ARE PACKETS THE SERVER RESPONDS TO!!!
enum enum_server_packets {
    //logins
    login_requested,
    heartbeat_request,
    //character aquisition
    character_query,
    character_created,
    character_loaded,
    //player entity
    player_entity_request,
    //movement
    movement_location_request,
    movement_location_update,
    //inventory
    entity_store,
    entity_throw, //flows into place
    entity_place,
    entity_drop, //not placing, unloading an entity from client inputs!
    entity_inventory_request,
}


//packet disassembly and processing
if async_load[? "type"] == network_type_data {
    //show_debug_message("Server has received packet: ");

    //cheap hack for throwing
    var entity_thrown = false;
    var throw_direction = 0;
    var throw_speed = 0;
    
    //get packet data
    var connection_id = async_load[? "id"];
    var connection_buffer = async_load[? "buffer"];
    var connection_bufsize = async_load[? "size"];
    
    //get the opcode off the packet!!
    var opcode = buffer_read(connection_buffer,buffer_u16);
    switch opcode {
    
        case  enum_server_packets.login_requested: 
            show_debug_message("===Login details submitted");
        
            //login attempt!
            var login_success   = false;
            var login_name      = buffer_read(connection_buffer,buffer_string); //stores length and ignores null terminator!
            var login_passhash  = buffer_read(connection_buffer,buffer_string); //stores length and ignores null terminator!
            
            //login checks
            login_success = true;
            
            //for now no logins, just trigger to the client that they logged in!
            scr_cpacket_login_return(connection_id,login_success);
        break;
        
        case enum_server_packets.heartbeat_request:
            //tell the client we are indeed still alive.
            scr_cpacket_server_alive(connection_id);
        break;
    
        case enum_server_packets.character_query:
            show_debug_message("===character requested");
        
            //check for character existance!
            var char_getname  = buffer_read(connection_buffer,buffer_string);
            
            //store that we should add a new player, and then falsify those claims if need be!
            var new_player = true;
            var player_in_use = false;
            
            //Check to see if this is a new player object!
            var found_same_name = false;
            var name_entity_slot = 0;
            while found_same_name == false and name_entity_slot &lt; ds_list_size(list_entities) {
                if ds_exists(list_entities[| name_entity_slot],ds_type_map) == true {
                    var check_player = list_entities[| name_entity_slot];
                    
                    if is_undefined(check_player[? "player_nickname"]) == false and check_player[? "player_nickname"] == string(char_getname) {
                        //log back in!
                        found_same_name = true;
                        new_player = false;
                        if !is_undefined(check_player[? "socket"]) and check_player[? "socket"] != -1 player_in_use = true;
                        break;
                    }
                    else
                    {
                        //not a player entity or not the same player
                        name_entity_slot++;
                    }
                }
                else
                {
                    //invalid slot to check. empty or glitched.
                    name_entity_slot++;
                }
            }
            
        
            //return if you need to make a char, or if this is your char!
            if new_player == true {
                //is a new player
                scr_cpacket_character_notfound(connection_id,char_getname);
            }
            else
            {
                //not a new player, send some entity data too!
                if player_in_use == false {
                    scr_cpacket_character_wasfound(connection_id,name_entity_slot);
                }
                else
                {
                    scr_cpacket_character_wasfound_inuse(connection_id);
                }
            }
        break;
        
    
        case enum_server_packets.character_created:
            show_debug_message("===character created");    
        
            //check for character existance!
            var char_getname  = buffer_read(connection_buffer,buffer_string);
        
            //a NEW player joined!
            var new_entity = scr_entity_template_library(obj_puppet_player,1904,1904,0,0,0,true,-1);
                new_entity[? "stasis"] = true; //start in stasis
            var new_player_entity = scr_server_entity_add(new_entity); //add to main list
            
            //add the entity_number to the player id list so it points to this!
            var found_slot = false;
            var player_slotid = 0;
            while found_slot == false {
                if player_slotid &gt; ds_list_size(list_player) or is_undefined(list_player[| player_slotid]) or ds_exists(list_player[| player_slotid],ds_type_map) == false {
                    //store the list reference number!
                    list_player[| player_slotid] = new_player_entity; //player list stores a reference to the player entity id
                    
                    //add data back to the map, do not use new_player_entity it is just the entity list reference number
                    new_entity[? "player_slot_id"] = player_slotid; //backstore this, for quick reference if needed!
                    new_entity[? "player_name"] = "Login name"; //backstore this, for quick reference if needed!
                    new_entity[? "player_nickname"] = char_getname; //backstore this, for quick reference if needed! firstname + lastname on char creation!
                    new_entity[? "stasis"] = false; //take player out of stasis 
                    
                    //lock the socket
                    list_sockets[| connection_id] = player_slotid; //point's to the player reference list.  sockets[] -&gt; player[] -&gt; entity[] -&gt; actual_map!
                    new_entity[? "player_socket"] = connection_id;
                    
                    //send final connection packet
                    scr_cpacket_character_lock(connection_id);
                    
                    //done!
                    found_slot = true; 
                    break;
                }
                else
                {
                    player_slotid++;
                }
            }
        break;
        
        
        case enum_server_packets.character_loaded:
            show_debug_message("===character loaded");
        
            //add the entity_number to the player id list so it points to this!
            var found_slot = false;
            var player_slotid = 0;
            while found_slot == false {
                if player_slotid &gt; ds_list_size(list_player) or is_undefined(list_player[| player_slotid]) or ds_exists(list_player[| player_slotid],ds_type_map) == false {
                     //use the entity we passed it before!
                    var new_player_entity = buffer_read(connection_buffer,buffer_u32);
                    
                    //store the list reference number!
                    list_player[| player_slotid] = new_player_entity; //player list stores a reference to the player entity id
                    
                    //lock the socket
                    list_sockets[| connection_id] = player_slotid; //point's to the player reference list.  sockets[] -&gt; player[] -&gt; entity[] -&gt; actual_map!
                    
                    //setup entity itself
                    var new_entity = list_entities[| new_player_entity];
                    if is_undefined(new_entity) == false and ds_exists(new_entity ,ds_type_map) {
                        new_entity[? "player_slot_id"] = player_slotid; //backstore this, for quick reference if needed!
                        new_entity[? "stasis"] = false; //take player out of stasis 
                        new_entity[? "player_socket"] = connection_id;
                        
                        //send final connection packet
                        scr_cpacket_character_lock(connection_id);
                    }
                    else
                    {
                        //somehow... we lost it...
                        scr_cpacket_force_reset(connection_id," -Character was lost before loading could be finished.");
                    }
                    
                    //flag as done
                    found_slot = true; //done!
                    break;
                }
                else
                {
                    player_slotid++;
                }
            }
        break;
    
        
        case enum_server_packets.player_entity_request:
            show_debug_message("===Player " + string(connection_id) + " requested their entity number.");
            var player_number = list_sockets[| connection_id]; 
            var player_entity = list_player[| player_number]; 
            
            if is_undefined(player_entity) == false and ds_exists(player_entity,ds_type_map) {
                //send entity number!
                scr_cpacket_playerentity_return(connection_id,player_entity);
            }
            else
            {
                //somehow... we lost it...
                scr_cpacket_force_reset(connection_id," -Character entity data was not found.");
            }
        break;
        
        
        case enum_server_packets.movement_location_request:
            var entity_number = buffer_read(connection_buffer,buffer_u32);
            var found_map = list_entities[| entity_number];
            
            show_debug_message("===location of " + string(entity_number) + " requested");
            
            if is_undefined(found_map) == false and ds_exists(found_map,ds_type_map) {
                show_debug_message(" -entity existed!");
                var xx = found_map[? "x"];
                var yy = found_map[? "y"];
                var zz = found_map[? "z"];
                var dir = found_map[? "dir"];
                var spd = found_map[? "spd"];
                
                
                //send location for the client to set itself to!
                scr_cpacket_location_sync(connection_id,xx,yy,zz,dir,spd);
                
                //this was likely a new joiner, or a desyncher, update the entities too
                scr_server_entity_flag_updateall();
            }
            else
            {
                show_debug_message("entity did not exist! Told client to drop it.");
                scr_cpacket_entity_drop(connection_id,entity_number);
            }
        break;
        
        
        case enum_server_packets.movement_location_update:
            var entity_number  = buffer_read(connection_buffer,buffer_u32);
            var found_map = list_entities[| entity_number];
            
            if is_undefined(found_map) == false and ds_exists(found_map,ds_type_map) {
                show_debug_message("===location of entity: " + string(entity_number) + " updated.");
            
                //set the location based off of this!
                if found_map[? "x"] &gt; -800 {
                    //clamping for inbound objects
                    found_map[? "x"] = clamp(buffer_read(connection_buffer,buffer_f32), 10, map_boundingx-10);
                    found_map[? "y"] = clamp(buffer_read(connection_buffer,buffer_f32), 10, map_boundingy-10);
                    found_map[? "z"] = buffer_read(connection_buffer,buffer_f32);
                }
                else
                {
                    //some special stuff happens far out in negative regions so
                    found_map[? "x"] = buffer_read(connection_buffer,buffer_f32);
                    found_map[? "y"] = buffer_read(connection_buffer,buffer_f32);
                    found_map[? "z"] = buffer_read(connection_buffer,buffer_f32);
                }
                
                //forces update
                scr_item_updateflag_allplayers(entity_number,true);
            }
            else
            {
                show_debug_message("===Location of entity: " + string(entity_number) + " could not be updated, entity missing. Client told to drop it.");
                scr_cpacket_entity_drop(connection_id,entity_number);
            }
        break;
        
        
        case enum_server_packets.entity_store:
            //item being stored!
            var entity_number  = buffer_read(connection_buffer,buffer_u32);
            var found_map = list_entities[| entity_number];
            
            //box to put it in (any entity supports this!
            var storagebox_entity_number  = buffer_read(connection_buffer,buffer_u32);
            var storagebox_map = list_entities[| storagebox_entity_number];
            
            //check if we can even access these!
            if is_undefined(found_map) == false and ds_exists(found_map,ds_type_map)
            and is_undefined(storagebox_map) == false and ds_exists(storagebox_map,ds_type_map) {
                if entity_number != storagebox_entity_number {
                    show_debug_message("===entity: " + string(entity_number) + " placed in inventory of: " + string(storagebox_entity_number));
                
                    //storage can only happen if the inventory for it is capable!
                    var allow_storage = true;
                    
                    //limit by sizes, huge cannot fit in anything unless done by unique means
                    if storagebox_map[? "contains_type_large"] == false       and (found_map[? "is_huge"] == true) {
                        allow_storage = false;
                        show_debug_message(" -too big: HUGE");
                        scr_cpacket_failed_action(connection_id,"Too massive put in this!");
                    }
                    else if storagebox_map[? "contains_type_medium"] == false and (found_map[? "is_huge"] == true or found_map[? "is_large"] == true) {
                        allow_storage = false;
                        show_debug_message(" -too big: large");
                        scr_cpacket_failed_action(connection_id,"Too huge put in this!");
                    }
                    else if storagebox_map[? "contains_type_small"] == false  and (found_map[? "is_huge"] == true or found_map[? "is_large"] == true or found_map[? "is_medium"] == true) {
                        allow_storage = false;
                        show_debug_message(" -too big: medium");
                        scr_cpacket_failed_action(connection_id,"Too large put in this!");
                    }
                    else if storagebox_map[? "contains_type_tiny"] == false  and (found_map[? "is_huge"] == true or found_map[? "is_large"] == true or found_map[? "is_medium"] == true or found_map[? "is_small"] == true) {
                        allow_storage = false;
                        show_debug_message(" -too big: small");
                        scr_cpacket_failed_action(connection_id,"Too big put in this!");
                    }
                    
                    //liquids are limited to one specific mode
                    if storagebox_map[? "contains_type_liquid"] == false and found_map[? "is_liquid"] == true {
                        allow_storage = false; //liquid storage is absolute.
                        show_debug_message(" -too big: is liquid!?");
                        scr_cpacket_failed_action(connection_id,"Container cannot store liquids!");
                    }
                    
                    //too much in inventory!
                    if ds_map_size(storagebox_map[? "contains_map"]) &gt;= storagebox_map[? "contains_max"] {
                        allow_storage = false; //liquid storage is absolute.
                        show_debug_message(" -this inventory is full");
                        scr_cpacket_failed_action(connection_id,"Container is full!");
                    }
                    
                    //if storage is possible allow you to put it safely away
                    if allow_storage == true {
                    
                        //remove from previous inventory before we add it to something else (even it's old inventory possibly!!)
                        if found_map[? "inside_of_id"] != -1 {
                            var get_host_entity = found_map[? "inside_of_id"];
                            var get_host_entity_map = list_entities[| get_host_entity ];
                            var host_entity_inventory = get_host_entity_map[? "contains_map"];
                            //delete the old key!
                            ds_map_delete(host_entity_inventory,entity_number);
                        } 
                    
                    
                        //set the location based off of this!
                        found_map[? "inside_of_id"] = storagebox_entity_number; //store inside of id!
                        found_map[? "x"] = item_storage_pos; //hide it away from grabby paws
                        found_map[? "y"] = item_storage_pos; //hide it away from grabby paws
                        found_map[? "dir"] = 0; //stop moving we got grabbed.
                        found_map[? "spd"] = 0;
                        
                        //add to the inventory of the other object!
                        var storage_map = storagebox_map[? "contains_map"];
                        storage_map[? entity_number] = entity_number; //store the entity inside a key pointing to that entity! we can itterate later using ds_map_next!
                        
                        
                        //forces update, mark all player flags as update forced!
                        scr_item_updateflag_allplayers(entity_number,true);
                        scr_item_updateflag_allplayers(storagebox_entity_number,true);
                        
                        //update inventories
                        scr_cpacket_storagebox_object_update(connection_id,entity_number,storagebox_entity_number);
                    }
                }
                else
                {
                    show_debug_message(" -Cannot place an object inside itself!");
                    scr_cpacket_failed_action(connection_id,"Cannot place an object inside itself!");
                }
            }
        break;
        
        
        case enum_server_packets.entity_throw:
            //flows into place, but gets the direction and speed first!
            var entity_thrown = true;
            var throw_direction = (buffer_read(connection_buffer,buffer_u16) / 65534) * 360;
            var throw_speed = buffer_read(connection_buffer,buffer_u16);
            
        case enum_server_packets.entity_place:
            //Take the entity outside of everything!
            
            //item being removed from storage
            var entity_number  = buffer_read(connection_buffer,buffer_u32);
            var found_map = list_entities[| entity_number];
            
            //storage it was in previously
            var storagebox_entity_number  = buffer_read(connection_buffer,buffer_u32);
            var storagebox_map = list_entities[| storagebox_entity_number];
            
            //check if we can even access these!
            if is_undefined(found_map) == false and ds_exists(found_map,ds_type_map)
            and is_undefined(storagebox_map) == false and ds_exists(storagebox_map,ds_type_map) {
                show_debug_message("===entity: " + string(entity_number) + " placed on ground. ");
            
                //set the location based off of this!
                found_map[? "inside_of_id"] = -1; //not stored inside anyone now
                found_map[? "x"] = buffer_read(connection_buffer,buffer_f32);
                found_map[? "y"] = buffer_read(connection_buffer,buffer_f32);
                found_map[? "z"] = buffer_read(connection_buffer,buffer_f32);
                
                if entity_thrown == true {
                    //do not update these normally, let the server handle thrown stuff more.
                    found_map[? "dir"] = throw_direction;
                    found_map[? "spd"] = throw_speed;
                }
                
                //remove from the inventory of the other object!
                ds_map_delete(storagebox_map[? "contains_map"],entity_number);
                
                //forces update, mark all player flags as update forced!
                scr_item_updateflag_allplayers(entity_number,true);
                scr_item_updateflag_allplayers(storagebox_entity_number,true);
                
                //update inventories
                scr_cpacket_storagebox_object_update(connection_id,entity_number,storagebox_entity_number);
            }
        break;
        
        
        case enum_server_packets.entity_drop:
            //flag the entity as something not loaded!
            var entity_number = buffer_read(connection_buffer,buffer_u32);
            show_debug_message("===Entity dropped: " + string(entity_number));
            
            if is_undefined(list_entities[| entity_number]) == false and ds_exists( list_entities[| entity_number], ds_type_map) == true {
                //tell client that this entity is also unloaded
                scr_cpacket_entity_drop(connection_id,entity_number);
                //set the object as needing to update when it can
                scr_item_set_update_flag( entity_number, list_sockets[| connection_id], true);
            }
            else
            {
                show_debug_message(" -Bad entity was attempting to be dropped: " + string(entity_number));
            }
        break;
        
        
        case enum_server_packets.entity_inventory_request:
            //request the inventory of any entity we need.
            var entity_number  = buffer_read(connection_buffer,buffer_u32);
            var instance_id_requesting  = buffer_read(connection_buffer,buffer_s32);
            
            scr_cpacket_inventory_update(connection_id,instance_id_requesting,entity_number);
        break;
        
        
        default:
            show_debug_message("===Unknown opcode... " + string( opcode));
        break;
    }
    
    //packet info
    if opcode != enum_server_packets.heartbeat_request {
        show_debug_message("Packet from socket: " + string(                connection_id ));
        show_debug_message(" -is player number: " + string( list_sockets[| connection_id]));
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///disconnection handling
if async_load[? "type"] == network_type_disconnect {
    var connection_id = async_load[? "socket"];
    
    if is_undefined(list_sockets[| connection_id]) == false {
        //get the player number
        var player_number = list_sockets[| connection_id]; 
        
        if ds_exists(player_number, ds_type_list) {
            //get the entity number
            var player_entity = list_player[| player_number]; 
            
            if ds_exists(player_entity, ds_type_list) {
                var player_map = list_entities[| player_entity]; //get the data structure from the entity list
                
                //handle the avatar
                if is_undefined(player_map) == false and ds_exists(player_map,ds_type_map) {
                    //set the player as in stasis...
                    player_map[? "stasis"] = true //take player out of stasis 
                    player_map[? "player_socket"] = -1; //clearout socket!!!
                }
            }
            
            //remove connected player
            list_player[| player_number] = -1; //no longer points to an entity
        }
        
        //removed locked socket
        list_sockets[| connection_id] = -1; //no longer points to a player 
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw entities on server!
var horizontal_offset = 1;
var current_line = 0;
for (var i=0; i&lt;ds_list_size(list_entities); i+=1)
{
    draw_text(x+horizontal_offset,y+1+(16*current_line),"Entity: " + string(i)); current_line++;

    if ds_exists(list_entities[| i],ds_type_map) == true {
        var get_map = list_entities[| i];
        //main data
        if is_undefined(get_map[? "object_index"]) draw_text(x+horizontal_offset+32,y+1+(16*current_line),"obj: MALFORMED") else 
            draw_text(x+horizontal_offset+32,y+1+(16*current_line),"obj: " + string(asset_get_index(get_map[? "object_index"]))); 
        current_line++;
        
        if is_undefined(get_map[? "x"]) draw_text(x+horizontal_offset+32,y+1+(16*current_line),"x: MALFORMED") else 
            draw_text(x+horizontal_offset+32,y+1+(16*current_line),"x: " + string(get_map[? "x"])); 
        current_line++;
        
        if is_undefined(get_map[? "y"]) draw_text(x+horizontal_offset+32,y+1+(16*current_line),"y: MALFORMED") else 
            draw_text(x+horizontal_offset+32,y+1+(16*current_line),"y: " + string(get_map[? "y"])); 
        current_line++;
        
        if is_undefined(get_map[? "z"]) draw_text(x+horizontal_offset+32,y+1+(16*current_line),"z: MALFORMED") else 
            draw_text(x+horizontal_offset+32,y+1+(16*current_line),"z: " + string(get_map[? "z"]));
        current_line++;
        
        //inventory
        if is_undefined(get_map[? "indestructable"]) draw_text(x+horizontal_offset+32,y+1+(16*current_line),"indestructable: MALFORMED") else 
            draw_text(x+horizontal_offset+32,y+1+(16*current_line),"indestructable: " + string(get_map[? "indestructable"]));
        current_line++;
        
        if is_undefined(get_map[? "inside_of_id"]) draw_text(x+horizontal_offset+32,y+1+(16*current_line),"inside of: MALFORMED") else 
            draw_text(x+horizontal_offset+32,y+1+(16*current_line),"inside of: " + string(get_map[? "inside_of_id"])); 
        current_line++;
        
        if is_undefined(get_map[? "contains_map"]) {
            draw_text(x+horizontal_offset+32,y+1+(16*current_line),"contains: MALFORMED"); current_line++;
        } 
        else 
        {
            draw_text(x+horizontal_offset+32,y+1+(16*current_line),"contains: "); current_line++;
            if ds_exists(get_map[? "contains_map"],ds_type_map) == true {
                var get_inventory = get_map[? "contains_map"];
                
                if ds_map_size(get_inventory) &gt; 0 {
                    draw_text(x+horizontal_offset+64,y+1+(16*current_line),"Size: " + string(ds_map_size(get_inventory))); current_line++;
                }
                else
                {
                    draw_text(x+horizontal_offset+64,y+1+(16*current_line),"None"); current_line++;
                }
            }
        }
        
        //space between entries
        current_line++;
    }
    else
    {
        draw_text(x+horizontal_offset+32,y+1+(16*current_line),"Empty or lost?"); current_line++; current_line++;
    }
}


//draw players on the server
var horizontal_offset = 257;
var current_line = 0;
for (var i=0; i&lt;ds_list_size(list_player); i+=1)
{
    var get_entity_index = list_player[| i];

    if is_undefined(list_entities[| get_entity_index]) == false and  ds_exists(list_entities[| get_entity_index],ds_type_map) == true {
        var get_map = list_entities[| get_entity_index]; //linked entity data!
         
        //player number
        if is_undefined(get_map[? "player_slot_id"]) draw_text(x+horizontal_offset,y+1+(16*current_line),"player: MALFORMED") else 
            draw_text(x+horizontal_offset,y+1+(16*current_line),"Player: " + string(get_map[? "player_slot_id"]));
        current_line++;
        
        //player linked iD
        draw_text(x+horizontal_offset+32,y+1+(16*current_line),"linked entity: " + string(list_player[| i])); current_line++;
        
        //main data
        if is_undefined(get_map[? "player_nickname"]) draw_text(x+horizontal_offset+32,y+1+(16*current_line),"name: MALFORMED") else 
            draw_text(x+horizontal_offset+32,y+1+(16*current_line),"name: " + string(get_map[? "player_nickname"]));
        current_line++;
        
        if is_undefined(get_map[? "player_socket"]) draw_text(x+horizontal_offset+32,y+1+(16*current_line),"socket: MALFORMED") else 
            draw_text(x+horizontal_offset+32,y+1+(16*current_line),"socket: " + string(get_map[? "player_socket"]));
        current_line++;
         
        
        //space between entries
        current_line++;
    }
    else
    {
        draw_text(x+horizontal_offset,y+1+(16*current_line),"player: " + string(i) + " DCed."); current_line++; current_line++;
    }
}

//sockets
var horizontal_offset = 450;
var current_line = 0;
for (var i=0; i&lt;ds_list_size(list_sockets); i+=1)
{
    if list_sockets[| i] != -1 draw_text(x+horizontal_offset,y+1+(16*current_line),string(i) + ":Sock-- " + string(list_sockets[| i])); current_line++; current_line++;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
