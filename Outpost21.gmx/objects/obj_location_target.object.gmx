<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_location_target</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///store data on what we are doing!
my_entity = -1; //set by context menu on create
storagebox_entity = -1;
minimum_range = 20;
nearest_inst = noone;
passed_object = -1;
alarm[0] = 5;

//jump to location
with obj_player {
    other.x = x;
    other.y = y;
}

//mode 
enum enum_targeter {
    placing,
    throwing,
    load, //probably for stuff like guns
    //unload, //same
    fill, //reskinned load(1slot)
    //drain, //reskinned unload(1slot)
    construct,
    shooting,
    door_security,
}
target_mode = enum_targeter.placing;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///redraw ui again
with obj_gui_element_parent {
    visible = true;
}
//forcibly remove shooting mode
if target_mode == enum_targeter.shooting {
    global.equiped_entity = -1;
    global.equiped_object = noone;
    global.equiped_ammo = -1;
}
//set a delay on the scanner
with obj_location_scanner alarm[0] = 10;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>wait till we are a few frames after to place or throw</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//align as needed
if instance_exists(obj_hostobject) and global.client_loading == false {

    //get the actual distance and direction needed
    dir = point_direction(obj_hostobject.x,obj_hostobject.y,mouse_x,mouse_y);
    dis = point_distance(obj_hostobject.x,obj_hostobject.y,mouse_x,mouse_y);
    
    if scr_mouse_over_inventory_button() == false {
        //if in the minimum range 
        if dis &lt; other.minimum_range {
            //move to player
            x = lerp(x,obj_hostobject.x,0.20);
            y = lerp(y,obj_hostobject.y,0.20);
            //destroy if clicking player, cause we canceled.
            if device_mouse_check_button_pressed(0,mb_left) and alarm[0] &lt;= 0 {
                //de-equip shooting weapons
                if target_mode == enum_targeter.shooting {
                    global.equiped_entity = -1;
                    global.equiped_object = noone;
                    global.equiped_ammo = -1;
                }
                //destroy
                instance_destroy();
            }
        }
        else
        {
            //make ui invis!
            with obj_gui_element_parent {
                if object_index != obj_gamecontrol visible = false;
            }
        
            //perform activities based on mode
            switch target_mode {
                //limited distance placing 
                case enum_targeter.placing:
                    if dis &gt; global.place_grab_range dis = global.place_grab_range; //limited to putting it down near you!
                    
                    //move me!
                    x = obj_hostobject.x + lengthdir_x(dis,dir);
                    y = obj_hostobject.y + lengthdir_y(dis,dir);
                    
                    
                    while collision_line(obj_hostobject.x,obj_hostobject.y,obj_hostobject.x + lengthdir_x(dis,dir),obj_hostobject.y + lengthdir_y(dis,dir),obj_wall,true,true) != noone or collision_rectangle(mouse_x-6,mouse_y-6,mouse_x+6,mouse_y+6,obj_wall,true,true) != noone {
                        //move me!
                        if dis &gt; 10 {
                            dis *= 0.90; //limited to putting it down near you!
                        }
                        else
                        {
                            dis = 10; //minimum
                            break;
                        }
                    }
                    
                case enum_targeter.throwing:
                    image_alpha = 1;
                    
                    //some stuff always uses construction alignments
                    var use_construct = false;
                    if passed_object != -1 and object_get_parent(passed_object) == obj_furniture_parent use_construct = true;
                    
                    //move me!
                    get_list = scr_construction_alignment( obj_hostobject.x + lengthdir_x(dis,dir), obj_hostobject.y + lengthdir_y(dis,dir), use_construct);
                    x = get_list[| 0];
                    y = get_list[| 1];
                    ds_list_destroy(get_list);
                    
                    
                    if device_mouse_check_button_pressed(0,mb_left) and alarm[0] &lt;= 0 {
                        if target_mode == enum_targeter.placing {
                            with obj_hostobject {
                                if point_distance(x,y,other.x,other.y) &gt;= other.minimum_range {
                                    scr_spacket_entity_place( other.my_entity, other.storagebox_entity, other.x,other.y);
                                    
                                    //drop equiped entity
                                    if other.my_entity == global.equiped_entity {
                                        global.equiped_entity = -1;
                                        global.equiped_object = noone;
                                    }
                                }
                            }
                            
                            //remove me!
                            instance_destroy();
                        }
                        else
                        {
                            with obj_hostobject {
                                if point_distance(x,y,other.x,other.y) &gt;= other.minimum_range {
                                    var dir = point_direction(x,y,other.x,other.y); //temp, i need to get a targeting tool in!
                                    var dis = clamp(point_distance(x,y,other.x,other.y)/128,0.10,1);
                                    scr_spacket_entity_throw( other.my_entity, other.storagebox_entity, x,y,dir,40*dis); //throw based on distance from you
                                    
                                    //drop equiped entity
                                    if other.my_entity == global.equiped_entity {
                                        global.equiped_entity = -1;
                                        global.equiped_object = noone;
                                    }
                                }
                            }
                            
                            //remove me!
                            instance_destroy();
                        }
                    }
                    
                    //set depth
                    scr_set_depth(y,-8); 
                break;
                
                
                //limited distance placing 
                case enum_targeter.load:
                case enum_targeter.fill:
                    if dis &gt; global.place_grab_range dis = global.place_grab_range; //limited to putting it down near you!
                    
                    nearest_inst = instance_nearest(obj_hostobject.x + lengthdir_x(dis,dir),obj_hostobject.y + lengthdir_y(dis,dir),obj_puppet);
                    
                    if instance_exists(nearest_inst) == true 
                    and point_distance(mouse_x,mouse_y,nearest_inst.x,nearest_inst.y) &lt;= 16 //snap range
                    and point_distance(obj_hostobject.x,obj_hostobject.y,nearest_inst.x,nearest_inst.y) &lt;= global.place_grab_range {
                        //in range allow it!
                        image_alpha = clamp(image_alpha+0.20,0.10,0.90);
                        
                        //move item!
                        x = lerp(x,nearest_inst.x,0.20);
                        y = lerp(y,nearest_inst.y,0.20);
                        
                        if device_mouse_check_button_pressed(0,mb_left) and alarm[0] &lt;= 0 {
                            //store an entity inside me!
                            if point_distance(obj_hostobject.x,obj_hostobject.y,nearest_inst.x,nearest_inst.y) &gt;= other.minimum_range {
                                scr_spacket_entity_store( nearest_inst.entityid, my_entity);
                            }
                            
                            //remove me!
                            instance_destroy();
                        }
                    }
                    else
                    {
                        //not in range, fade out
                        image_alpha = clamp(image_alpha-0.20,0.10,0.90);
                        
                        //move me!
                        x = obj_hostobject.x + lengthdir_x(dis,dir);
                        y = obj_hostobject.y + lengthdir_y(dis,dir);
                    }
                    
                    //set depth
                    scr_set_depth(y,-8); 
                break;
                
                case enum_targeter.construct: 
                    if dis &gt; 70 dis = 70; //limited to putting it down near you!
                    
                    //allow placement if line of sight is valid!
                    while collision_line(obj_hostobject.x,obj_hostobject.y,x,y,obj_wall,true,true) != noone or collision_rectangle(mouse_x-6,mouse_y-6,mouse_x+6,mouse_y+6,obj_wall,true,true) != noone {
                        //move me!
                        if dis &gt; 10 {
                            dis *= 0.90; //limited to putting it down near you!
                        }
                        else
                        {
                            dis = 10; //minimum
                            break;
                        }
                    }
                    image_alpha = 1;
                     
                    //move me!
                    var get_list = scr_construction_alignment( obj_hostobject.x + lengthdir_x(dis,dir), obj_hostobject.y + lengthdir_y(dis,dir), true);
                    x = get_list[| 0];
                    y = get_list[| 1];
                    ds_list_destroy(get_list);
                    
                    //mouse inputs
                    if device_mouse_check_button_pressed(0,mb_left) and alarm[0] &lt;= 0 and scr_construction_exclusion(passed_object,x,y) {
                        with obj_hostobject {
                            if point_distance(x,y,other.x,other.y) &gt;= other.minimum_range {
                                scr_spacket_entity_construct( other.my_entity, other.storagebox_entity, other.x,other.y);
                            }
                        }
                        
                        //remove me!
                        instance_destroy();
                    }
                    
                    //set depth
                    scr_set_depth(y,-8); 
                break;
                
                case enum_targeter.shooting:
                    //assumes equiped entity
                    if my_entity == global.equiped_entity {
                        //get player location
                        var plx = x;
                        var ply = y;   
                        with obj_hostobject {
                            if mouse_x &lt; x image_xscale = -1 else image_xscale = 1; //face shot!
                            plx = x+(10*image_xscale);
                            ply = y-20;
                        }
                        
                        //move me!
                        dir = point_direction(plx,ply,mouse_x,mouse_y);
                        dis = point_distance(plx,ply,mouse_x,mouse_y);
                        x = plx + lengthdir_x(dis,dir);
                        y = ply + lengthdir_y(dis,dir);
                    
                        //fire! maybe...
                        if device_mouse_check_button_pressed(0,mb_left) and alarm[0] &lt;= 0 {
                            if global.equiped_ammo &gt; 0 {
                                //act based on weapon
                                switch global.equiped_object {
                                    case obj_puppet_laserrifle:
                                        with obj_hostobject {
                                            scr_spacket_entity_interact(global.equiped_entity,other.id,1); //request ammo count after a shot! 
                                            scr_spacket_entity_create_direction( plx, ply, obj_puppet_laserpoint, dir);
                                        }
                                    break;
                                    
                                }
                                //trigger wait
                                alarm[0] = 20;
                            }
                            else if global.equiped_ammo != -1 { // no message on ammo count loading in. only on empty!
                                scr_client_errormessage("Amunition expended.");
                            }
                        }
                    }
                    
                    //set depth
                    scr_set_depth(y,-8); 
                break; 
                
                case enum_targeter.door_security:
                    var snap_range = 24;
                    var nearest_inst = noone;
                    with obj_door {
                        if point_distance(x,y,mouse_x,mouse_y) &lt; snap_range 
                        and point_distance(obj_hostobject.x,obj_hostobject.y,x,y) &lt;= global.place_grab_range
                        and point_in_rectangle(mouse_x,mouse_y,x-15,y-15,x+15,y+15) nearest_inst = id;
                    }
                    
                    //get the actual distance and direction needed
                    if instance_exists(nearest_inst) {
                        dir = point_direction(obj_hostobject.x,obj_hostobject.y,nearest_inst.x,nearest_inst.y);
                        dis = point_distance(obj_hostobject.x,obj_hostobject.y,nearest_inst.x,nearest_inst.y);
                        
                        if device_mouse_check_button_pressed(0,mb_left) and alarm[0] &lt;= 0 {
                            //spawn door menu!
                            //make programming menu, ask the card reader to check its inventory and return a menu based on the card inside it
                            scr_spacket_security_tool_requestdoor( nearest_inst.construction_id); //trigger event in security object, this returns the security data in the card and makes a menu!
                            //cancel context
                            instance_destroy();
                        }
                    }
                    else
                    {
                        dir = point_direction(obj_hostobject.x,obj_hostobject.y,mouse_x,mouse_y);
                        dis = point_distance(obj_hostobject.x,obj_hostobject.y,mouse_x,mouse_y);
                    }
                    
                    //distance locked
                    if dis &gt; global.place_grab_range dis = global.place_grab_range; //limited to putting it down near you!
                    
                    //move me!
                    x = obj_hostobject.x + lengthdir_x(dis,dir);
                    y = obj_hostobject.y + lengthdir_y(dis,dir);
                    
                    //set depth
                    scr_set_depth(y,-2000); 
                break;
            }
        }
    }  
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//get distance to
if instance_exists(obj_hostobject) {
    var dir = 0;
    var dis = 0;

    //get the distance to the player, and disable it if too close
    dir = point_direction(x,y,obj_hostobject.x,obj_hostobject.y);
    dis = point_distance(x,y,obj_hostobject.x,obj_hostobject.y);
    if dis &lt; minimum_range dis = 0; //let you know it goes back in your inventory
    
    //cursor
    var xoff = lengthdir_x(dis,dir);
    var yoff = lengthdir_y(dis,dir);
    image_angle += 2;
    draw_sprite_ext(spr_location_target,0,obj_hostobject.x-xoff,obj_hostobject.y-yoff,1,1,image_angle,image_blend,0.75);
    
    switch target_mode {
        case enum_targeter.placing:
        case enum_targeter.throwing:
        case enum_targeter.construct:
            //faded object
            draw_sprite_ext(object_get_sprite(passed_object),0,obj_hostobject.x-xoff,obj_hostobject.y-yoff,1,1,0,image_blend,0.50);
        break;
    }
    
    //beads
    for (var i=0; i&lt;1; i+=0.20)
    {
        //draw dots between you and it!
        var xoff = lengthdir_x(dis*i,dir);
        var yoff = lengthdir_y(dis*i,dir);
        draw_sprite(spr_location_target,1,obj_hostobject.x-xoff,obj_hostobject.y-yoff);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
