<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2000</depth>
  <persistent>0</persistent>
  <parentName>obj_gui_element_parent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//view zoom
view_zoom_scale = 1;
view_defaultw = view_wview[0];
view_defaulth = view_hview[0];

//main selection marker
player_scanner = instance_create(0,0,obj_location_scanner);

inv_dragger_alpha = 0;
stepstep = 0;

//overlay for fps
show_debug_overlay(debug_mode);
overlay = false;

//shadows
last_cast_x = 0;
last_cast_y = 0;

//weather x/y
weatherxscale = 10;
weatheryscale = 10;

//hud data, "name", spawn object
hud_slot[0,0] = "Inventory";
hud_slot[0,1] = obj_inventory_player;
hud_slot[0,2] = noone; //instance created by the button, closes on next press if it exists


//construction mode
current_item = 0;
//walls
var i = 0;
construction_array[i,0] = obj_wall;             //object
construction_array[i,1] = spr_wall_mask;    //sprite_index
construction_array[i,2] = 0;                    //image_index
construction_array[i,3] = 90;                    //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 8;                    //ydraw offset
construction_array[i,6] = 0;                    //grid offsetx
construction_array[i,7] = 0;                    //grid offsety
i++;
construction_array[i,0] = obj_wall;             //object
construction_array[i,1] = spr_wall_mask;    //sprite_index
construction_array[i,2] = 1;                    //image_index
construction_array[i,3] = 0;                    //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 32;                    //ydraw offset
construction_array[i,6] = 32;                    //grid offsetx
construction_array[i,7] = 32;                    //grid offsety
i++
construction_array[i,0] = obj_wall_tunnel;             //object
construction_array[i,1] = spr_wall_mask;    //sprite_index
construction_array[i,2] = 0;                    //image_index
construction_array[i,3] = 90;                    //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 8;                    //ydraw offset
construction_array[i,6] = 0;                    //grid offsetx
construction_array[i,7] = 0;                    //grid offsety
i++;
construction_array[i,0] = obj_wall_tunnel;             //object
construction_array[i,1] = spr_wall_mask;    //sprite_index
construction_array[i,2] = 1;                    //image_index
construction_array[i,3] = 0;                    //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 32;                    //ydraw offset
construction_array[i,6] = 32;                    //grid offsetx
construction_array[i,7] = 32;                    //grid offsety
//windows
i++;
construction_array[i,0] = obj_window;             //object
construction_array[i,1] = spr_wall_mask;    //sprite_index
construction_array[i,2] = 0;                    //image_index
construction_array[i,3] = 90;                    //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 8;                    //ydraw offset
construction_array[i,6] = 0;                    //grid offsetx
construction_array[i,7] = 0;                    //grid offsety
i++;
construction_array[i,0] = obj_window;           //object
construction_array[i,1] = spr_wall_mask;  //sprite_index
construction_array[i,2] = 1;                    //image_index
construction_array[i,3] = 0;                   //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 32;                    //ydraw offset
construction_array[i,6] = 32;                    //grid offsetx
construction_array[i,7] = 32;                    //grid offsety
//doors
i++;
construction_array[i,0] = obj_door;             //object
construction_array[i,1] = spr_wall_mask;    //sprite_index
construction_array[i,2] = 0;                    //image_index
construction_array[i,3] = 90;                    //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 8;                    //ydraw offset
construction_array[i,6] = 0;                    //grid offsetx
construction_array[i,7] = 0;                    //grid offsety

i++;
construction_array[i,0] = obj_door;           //object
construction_array[i,1] = spr_wall_mask;  //sprite_index
construction_array[i,2] = 1;                    //image_index
construction_array[i,3] = 0;                   //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 32;                    //ydraw offset
construction_array[i,6] = 32;                    //grid offsetx
construction_array[i,7] = 32;                    //grid offsety
//fencing
i++;
construction_array[i,0] = obj_fence;             //object
construction_array[i,1] = spr_wall_mask;    //sprite_index
construction_array[i,2] = 0;                    //image_index
construction_array[i,3] = 90;                    //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 8;                    //ydraw offset
construction_array[i,6] = 0;                    //grid offsetx
construction_array[i,7] = 0;                    //grid offsety
i++;
construction_array[i,0] = obj_fence;           //object
construction_array[i,1] = spr_wall_mask;  //sprite_index
construction_array[i,2] = 1;                    //image_index
construction_array[i,3] = 0;                   //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 32;                    //ydraw offset
construction_array[i,6] = 32;                    //grid offsetx
construction_array[i,7] = 32;                    //grid offsety
//floors
i++;
construction_array[i,0] = obj_floor;           //object
construction_array[i,1] = spr_floormask;  //sprite_index
construction_array[i,2] = 0;                    //image_index
construction_array[i,3] = 0;                   //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 0;                    //ydraw offset
construction_array[i,6] = 0;                    //grid offsetx
construction_array[i,7] = +32;                    //grid offsety
//floors
i++;
construction_array[i,0] = obj_floor_tunnel;           //object
construction_array[i,1] = spr_floormask;  //sprite_index
construction_array[i,2] = 0;                    //image_index
construction_array[i,3] = 0;                   //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 0;                    //ydraw offset
construction_array[i,6] = 0;                    //grid offsetx
construction_array[i,7] = +32;                    //grid offsety
//roads
i++;
construction_array[i,0] = obj_road;           //object
construction_array[i,1] = spr_road_dirt;  //sprite_index
construction_array[i,2] = 0;                    //image_index
construction_array[i,3] = 0;                   //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 0;                    //ydraw offset
construction_array[i,6] = 0;                    //grid offsetx
construction_array[i,7] = +32;                    //grid offsety=
//landing site
i++;
construction_array[i,0] = obj_landingpad;           //object
construction_array[i,1] = spr_shuttle_site;  //sprite_index
construction_array[i,2] = 0;                    //image_index
construction_array[i,3] = 0;                   //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 0;                    //ydraw offset
construction_array[i,6] = 0;                    //grid offsetx
construction_array[i,7] = +32;                    //grid offsety=
//railwayA
i++;
construction_array[i,0] = obj_railwayvert;           //object
construction_array[i,1] = spr_railway_mask;  //sprite_index
construction_array[i,2] = 0;                    //image_index
construction_array[i,3] = 0;                   //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 0;                    //ydraw offset
construction_array[i,6] = -32;                    //grid offsetx
construction_array[i,7] = 0;                    //grid offsety=
//railwayB
i++;
construction_array[i,0] = obj_railwayhor;           //object
construction_array[i,1] = spr_railway_mask;  //sprite_index
construction_array[i,2] = 0;                    //image_index
construction_array[i,3] = 0;                   //construction angle
construction_array[i,4] = 0;                    //xdraw offset
construction_array[i,5] = 0;                    //ydraw offset
construction_array[i,6] = -32;                    //grid offsetx
construction_array[i,7] = 0;                    //grid offsety=
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///init shadow casting
vertex_format_begin();
vertex_format_add_position();
vertex_format_add_color();
VertexFormat = vertex_format_end();
VBuffer = vertex_create_buffer();

LightPosRadius = shader_get_uniform(shader_shadows,"u_fLightPositionRadius");

/*
var i = 0;
while i &lt; view_hview[0] {
    instance_create(0,i,obj_lightlayers);
    i += 1;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>201</id>
        <kind>0</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_create_object</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>10</kind>
            <object>obj_weatherflower</object>
          </argument>
          <argument>
            <kind>0</kind>
            <string>0</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if global.construction_mode == true {
    //follow mouse
    x = lerp(x,mouse_x,0.30);
    y = lerp(y,mouse_y,0.30);
    //borders
    view_hborder[0] = 40;
    view_vborder[0] = 40;
    //tile_layer_show(ground_tile_depth);
}
else
{
    //snap onto player
    with obj_hostobject {
        other.x = x;
        other.y = y;
    }
    //borders
    view_hborder[0] = 400;
    view_vborder[0] = 300;
    /*
    if global.player_indoors == true {
        tile_layer_hide(ground_tile_depth);
    }
    else
    {
        tile_layer_show(ground_tile_depth);
    }*/
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///use the buttons on this gui element to decide if the mouse is inside it!
var mouse_clicked_me = false;

var mouse_guix = device_mouse_x_to_gui(0);
var mouse_guiy = device_mouse_y_to_gui(0);

var tile_width = -96;
var button_height = -32;
var max_tiles = 1;

if mouse_check_button_pressed(mb_left) and point_in_rectangle(mouse_guix,mouse_guiy,576+tile_width+tile_width+(0*tile_width),324+button_height,576+tile_width+(0*tile_width),324) {
    mouse_clicked_me = true;
}

//because more then one press on the above thing can trigger this!
scr_inventory_object_interaldepthcalculate(mouse_clicked_me);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//set the view to a custom surface
view_surf = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="76">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///view preconfiguration
depth = -2000;

//lock in grid
view_xview[0] = floor(view_xview[0]);
view_yview[0] = floor(view_yview[0]);

view_xview[1] = view_xview[0]-16;
view_yview[1] = view_yview[0]-34;

if global.construction_mode == true {
    //zoom in and out
    if keyboard_check(ord("+")) or mouse_wheel_up() {
        view_zoom_scale -= 0.025;
        if view_zoom_scale &lt; 0.5 view_zoom_scale = 0.5;
    }
    else if keyboard_check(ord("-")) or mouse_wheel_down() {
        view_zoom_scale += 0.025;
        if view_zoom_scale &gt; 5 view_zoom_scale = 5;
    }
    
    //view scaling
    view_wview[0] = view_defaultw * view_zoom_scale;
    view_hview[0] = view_defaulth * view_zoom_scale;
}
else
{
    //view scaling
    view_zoom_scale = 1;
    view_wview[0] = view_defaultw * view_zoom_scale;
    view_hview[0] = view_defaulth * view_zoom_scale;
}



//reset this
with global.client_top_gui_window scr_inventory_object_depthsetting(); //set the current window on top!!!
scr_inventory_object_depthordering();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var min_load_perc = 0.30;
if global.client_loading == true {
    draw_set_color(c_black);
    draw_rectangle(-10,-10,1024,1024,false);
    
    draw_set_color(c_gray);
    draw_rectangle(10,10,566,30,true);
    draw_rectangle(10,10,lerp(10,566,global.client_loading_progress),30,false);
    
    draw_set_color(c_green); //min load point
    draw_arrow(lerp(10,566,min_load_perc),50,lerp(10,566,min_load_perc),30,10);
    
    draw_set_color(c_black);
    draw_text(15,15,100*global.client_loading_progress);

    if global.client_loading_progress &gt; min_load_perc {
        //loading flag finished
        global.client_loading = false;
        //send notice to server that my shuttle is ready! server handles it if we are inside or not.
        scr_spacket_client_map_preloaded();
    }
}
else if global.client_loading_progress &lt; 0.90 {
    var rad = global.last_load_distance;
    draw_set_color(c_red);
    draw_rectangle(global.player_startx-rad-view_xview[0],global.player_starty-rad-view_yview[0],global.player_startx+rad-view_xview[0],global.player_starty+rad-view_yview[0],true);
    
    draw_set_color(c_black);
    with obj_hostobject {
        if object_index != obj_host_followpuppet { //not locked into bounds...
            x = clamp(x,global.player_startx-rad,global.player_startx+rad);
            y = clamp(y,global.player_starty-rad,global.player_starty+rad);
        }
    }
}

//with obj_client {
//    draw_set_color(c_white);
//    draw_text(10,296,debug_buffer_size);
//}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///start drawing hud
draw_sprite(spr_hud_basic,4,576,324);

//draw equiped item
stepstep += 0.04;
if global.equiped_object != noone {
    draw_sprite_ext( global.obj_sprites[| global.equiped_object], 0,576-38,324-38,1.7,1.7,sin(stepstep),image_blend,1);
    draw_set_color(c_white);
    if global.equiped_ammo != -1 draw_text(576-48,324-16,global.equiped_ammo );
}

//draw ui
var mouse_guix = device_mouse_x_to_gui(0);
var mouse_guiy = device_mouse_y_to_gui(0);

var tile_width = -96;
var button_height = -32;
var max_tiles = array_height_2d(hud_slot);

for (var i=0; i&lt;=max_tiles; i+=1) {
    if i &lt; max_tiles {
        //draw each button
        if point_in_rectangle(mouse_guix,mouse_guiy,576+tile_width+tile_width+(i*tile_width),324+button_height,576+tile_width+(i*tile_width),324) {
            //mouse over button
            if device_mouse_check_button_pressed(0,mb_left) and global.client_top_gui_window == id and scr_client_controllock() == false {
                //mouse over
                draw_sprite(spr_hud_basic,3,576+tile_width+(i*tile_width),324);
                
                //these buttons cancel aiming and such
                if instance_exists(obj_location_target) {
                    with obj_location_target instance_destroy();
                }
                else
                {
                    //make the instance or remove it
                    if instance_exists( hud_slot[i,2] ) == false {
                        hud_slot[i,2] = instance_create(0,0,hud_slot[i,1]);
                    }
                    else
                    {
                        with hud_slot[i,2] instance_destroy();
                    }
                }
            }
            else
            {
                //pressed
                draw_sprite(spr_hud_basic,2,576+tile_width+(i*tile_width),324);
            }
        }
        else
        {
            //mouse not touching
            draw_sprite(spr_hud_basic,1,576+tile_width+(i*tile_width),324);
        }
        
        //draw button text
        draw_text(576+tile_width+tile_width+(i*tile_width)+6,324+button_height+10,hud_slot[i,0]);
    }
    else
    {
        //cap
        draw_sprite(spr_hud_basic,0,576+tile_width+(i*tile_width),324);
    }
}


//draw dragging items
if global.inventory_drag_entity != -1 {
    inv_dragger_alpha = clamp(inv_dragger_alpha + 0.08,0,0.75);
    draw_sprite_ext( global.obj_sprites[| global.inventory_drag_entity_object] ,0,mouse_guix,mouse_guiy,0.5,0.5,0,image_blend,inv_dragger_alpha);
}
else
{
    inv_dragger_alpha = 0;
}


if global.construction_mode == true {
    var divm = 64;
    
    draw_set_color(c_white);
    draw_rectangle(0,0,room_width/divm,room_height/divm,true);
    draw_set_color(c_red);
    draw_rectangle(view_xview[0]/divm,view_yview[0]/divm,(view_xview[0]+view_wview[0])/divm,(view_yview[0]+view_hview[0])/divm,true);
    draw_set_color(c_black);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///construction ui
if global.construction_mode == true {

    var xx = 64 * (mouse_x div 64);
    var yy = 64 * (mouse_y div 64);
    
    var dxx = 32 * (mouse_x div 32);
    var dyy = 32 * (mouse_y div 32);
    
    draw_sprite_ext(construction_array[current_item,1],construction_array[current_item,2],xx+construction_array[current_item,4]+construction_array[current_item,6],yy+construction_array[current_item,5]+construction_array[current_item,7],1,1,construction_array[current_item,3],c_white,0.80);
    
    if keyboard_check_pressed(vk_right) and current_item &lt; array_height_2d(construction_array)-1 current_item += 1;
    if keyboard_check_pressed(vk_left) and current_item &gt; 0 current_item -= 1;
    
    if device_mouse_check_button_pressed(0,mb_left) {
        if instance_exists(obj_client) == false {
            with instance_create(xx+construction_array[current_item,6],yy+construction_array[current_item,7],construction_array[current_item,0]) {
                image_angle = other.construction_array[other.current_item,3]; //place at angle.
                event_user(13);
            }
        }
        else
        {
            //tell server to make it!
            scr_spacket_map_object_create(construction_array[current_item,0],xx+construction_array[current_item,6],yy+construction_array[current_item,7],100,construction_array[other.current_item,3]);
        }
    }
    
    //text help
    draw_text(mouse_x-32,mouse_y-40,object_get_name(construction_array[current_item,0]));
    
    
    if device_mouse_check_button(0,mb_right) {
        with instance_position( dxx, dyy, obj_construction ) {
            scr_spacket_map_object_destroy(construction_id);
            instance_destroy();
        }
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///shadow casting
var surface_border = 64;
if global.construction_mode == false {
    if surface_exists(global.shadow_surface) == false {
        global.shadow_surface = surface_create(view_wview[0]+surface_border,view_hview[0]+surface_border);
    }
    
    if instance_exists(obj_hostobject) {
        //slower updates
        if point_distance(view_xview[0],view_yview[0],last_cast_x,last_cast_y) &gt; 5 or current_time mod 4 == 0 {
            //update render pos
            last_cast_x = view_xview[0];
            last_cast_y = view_yview[0];
        
            //draw shadows
            surface_set_target(global.shadow_surface);
                draw_clear_alpha(c_black,0);
                /*
                draw_set_blend_mode(bm_subtract);
                
                //other lights
                with obj_lightsource {
                    if point_distance(obj_player.x,obj_player.y,x,y) &lt; (radius*2) {
                        if surface_exists(my_surface) and visible draw_surface_ext( my_surface, (x-(radius)) - view_xview[0], (y-(radius)) - view_yview[0],1,1,0,image_blend,1);
                        //draw_arrow(0,0,(x-(radius/2)) - view_xview[0],(y-(radius/2)) - view_yview[0],10);
                    }
                }
                */
                //main wall shadows
                draw_set_blend_mode(bm_add);
                scr_castshadows_main( obj_hostobject.x, obj_hostobject.y, global.player_light, view_xview[0]-(surface_border/2), view_yview[0]-(surface_border/2), 0, -32);
            surface_reset_target();
        }
        
        //draw shadows
        shader_set(shader_shadows);
            //draw my final layer
            draw_set_blend_mode(bm_normal);
            shader_set_uniform_f( LightPosRadius, obj_hostobject.x, obj_hostobject.y, global.player_light*0.80, 0.0);
            draw_surface_stretched( global.shadow_surface, last_cast_x-(surface_border/2), last_cast_y-(surface_border/2), view_wview[0]+surface_border, view_hview[0]+surface_border);
        shader_reset();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="79">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>overlay = !overlay;
show_debug_overlay(overlay);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="118">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.construction_mode = !global.construction_mode;

if global.construction_mode == true {
    with obj_location_target instance_destroy();
    with obj_inventory_parent instance_destroy();
    with obj_contextmenu instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
